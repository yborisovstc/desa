<?xml version="1.0" ?>

<!DOCTYPE article SYSTEM "/usr/share/sgml/docbook/dtd/xml/4.5/docbookx.dtd">


<article status="draft" class="specification"> <title>Discrete Events System asynchronous 
	framework. Design.</title>

    <articleinfo>
	<author><personname><firstname>Yuri</firstname><surname>Borisov</surname></personname>
	    <email>yuri.borisov.v@gmail.com</email></author> 

	<releaseinfo>Ver.0.01 at 10-May-2017</releaseinfo>

	<abstract>
	    <simpara>This document outlines desing of Discrete Events System Asyncronous Framework</simpara>
	</abstract>

	<revhistory>
	    <revision> <revnumber>0.01</revnumber> <date>10-Mar-2017</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Initial version</revremark> </revision>
	</revhistory>

    </articleinfo>

    <bibliolist><title>References</title>
	<biblioentry id="ref_incr_mut"> <abbrev>INCR_MUT</abbrev>
	    <productname><ulink url="../../../fap-doc/doc_incr_syst_creation/index.html "/></productname>
	    <title>Y.Borisov. Using incremental mutation process for systems modeling</title> </biblioentry>
	<biblioentry id="ref_dsa_swd"> <abbrev>DSA_SWD</abbrev>
	    <productname><ulink url="../../../fap-doc/doc_dsa_in_swd/index.html"/></productname>
	    <title>Using of Synchronous Discrete Time System paradigm in software development</title> </biblioentry>
    </bibliolist>


    <glossary> <title>Glossary</title> 
	<glossentry id="gls_cp"><glossterm>CP</glossterm> <acronym>CP</acronym>
	    <glossdef> <para>Connection Point</para> <para>
		    Element that is used as endpoint of connections between systems.  
	</para></glossdef> </glossentry>
	<glossentry id="gls_daa"><glossterm>DAA</glossterm> <acronym>DAA</acronym>
	    <glossdef> <para>Distributed Agents Approach</para> <para>
		    Approach of multi-agent system that assumes that the modes is distributed among several environments that 
		    can be running on undependent executable enviromnents.
		    Ref <ulink url="../../../grayb/doc/design/index.html#ds_daa"/> </para></glossdef> </glossentry>
	<glossentry id="gls_des"><glossterm>DES</glossterm> <acronym>DES</acronym>
	    <glossdef> <para>Discrete Events System - a discrete-state, event-driven system of which the state
		    evolution depends entirely on the occurrence of asynchronous discrete events over time.
		    DES consists solely of discrete state spaces and event-driven state transition mechanisms.
		    Ref <ulink url="https://en.wikipedia.org/wiki/Discrete_event_dynamic_system"/>
	</para></glossdef> </glossentry>
	<glossentry id="gls_dhc"><glossterm>DHC</glossterm> <acronym>DHC</acronym>
	    <glossdef> <para>Direct Hierarchical Chromosome</para> <para>
		    Approach of multi-agent system definition that describes the model's structure directly. 
		    Ref <ulink url="../../../grayb/doc/design/index.html#ds_smc"/> </para></glossdef> </glossentry>
	<glossentry id="gls_ep"><glossterm>EP</glossterm> <acronym>EP</acronym>
	    <glossdef> <para>Extention Point</para> <para>
		    Element that is used as mediator between two <xref linkend="gls_cp"/>. It is used to "extend" objects internal connection point
		    to the object iface.
	</para></glossdef> </glossentry>
	<glossentry id="gls_fapws"><glossterm>FAPWS</glossterm> <acronym>FAPWS</acronym>
	    <glossdef> <para>Finite Automata Programming Workspace</para> <para>
		    Initial project dedicated to creation C++ API for <xref linkend="gls_des"/>.
		    Ref <ulink url="../../../fapws"/> </para></glossdef> </glossentry>
	<glossentry id="gls_cco"><glossterm>CCO</glossterm> <acronym>CCO</acronym>
	    <glossdef> <para>Common context for non blocking operation - 
		    approach for non-blocking interaction between objects where the conext is initially prepared for the whole
		    operation, so the operation can be created in the form of class with attributes as context and methods as callbacks.
		    Ref <xref linkend="ds_smcsc_cco"/> for details.</para></glossdef> </glossentry>
    </glossary>

    <sect1 id="ds_intro"> <title>Introduction</title>
	<sect2 id="ds_intro_i"><title>Retrospective</title>
	    <simpara>This project is continuation of development of modelling environment basing on 
		<xref linkend="gls_des"/>. There were two attempts to create such an environment. The first 
		project FAPWS was for creating C++ framework basing on ideas of synchronous events system. The 
		system here runs in system time each tick of that causes the system update.
		Ref <xref linkend="ref_dsa_swd"/> for outline of the approach. The framework was developed and
		verified. Ref <ulink url="../../../fap-balls/"/>  for one test application simulating the
		dynamics of clashing balls in the 2d space.</simpara>
	    <simpara>Main part of concept of the framework was using of configurable connections in order to 
		assemble the system from system parts - states and subsystem. It was seen that the implementation of
		connections had many limitations that makes system creation hard and unsafe. Also transition
		function configuration was not implemented in the scope of the project base approach.
		So it was realized that we need some base framework to build DES fremwork itself.</simpara>
	    <simpara>Multiagent framework was suggested as the build base for DES framework. The project GRAYB was
		initiated for creating multiagent based DES, ref <ulink url="../../../grayb/"/> for the
		project. The idea of that framework was to have base configurable environment that consists of 
		many atomic elements - agents. The base agent supports just changing from configuration spec ("chromosome").
		The changing also includes creating new agent basing on existing agent. In order to get access to any
		agents they are organized as native hierarchies with owner-owned and parent-child relations.
		Also the specialized agents were introduced for creating some layers of modelling. For instance 
		the DES systems connection problems detected in FAPWS was solved by implementing graph layer with
		dedicated agent for "edge".  So the creating of the whole system is the process of evolving root
		agent's chromosome.  </simpara>
	    <simpara>The next step of multi-agent approach evolution was distributed mutli-agent system. The project
		was created for that - "FAP2-SRV", ref <ulink url="../../../fap2-srv/"/>. The main approach for 
		distributing the multi-agent system was creating of agents proxies that "hide" the real agent from
		the "client" when the agent was in remote environment. Proxy in that case interacts to the real agent
		via RPC. But there was problem realized that synchronous API of agent makes the RPC complex. Is was
		seemed that the interaction can be silmplified if we managed to create agent with asynchronous API.
		But what would be approach of such async agents? The initial idea is to use DES again but on 
		level of agents framework.
	    </simpara>
	</sect2>
	<sect2><title>How to make multi-agents asynchronous.</title>
	    <simpara>Let's look at the nature of the current MA implementation. The base comes from nature of native processing modeli (i.e. C++ on typical
		HW arch), where the system is the set of objects. An object is normally state machine: i.e. there is some data (context, attributes, etc.) and
		events (methods, APIs, etc). Particularly in grayb the object can implements a set of simple interfaces that affects same context.
		There is also mechanism to obtain required interface of object. Element (agent) in grayb multiagent environment is just such object with
		specific set of interfaces. This interfaces supports base agent functionality like mutability, native hierarchy,
		navigation in the hierarchy etc.</simpara>
	    <simpara>So the first thought of how to transform such system to async was just to ensure that all interfaces are asyncronous.
		This seems quite complicated task requiring full redesign of grayb. This is because in that case we need to implement specific state
		machine for each of interfaces. So the idea was to use one universal state machine mechanism for implementing these interfaces
		state machines. Low level DES seems to be one of the candidates for such mechanism.</simpara>
	    <simpara>We need not just implement particular interface asynchronously but also change interface itself. For instance the method that directly
		returns some data needs to be re-organized with usage of client-observer.</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_chaci"><title>Analysis: changing agents content interaction</title>
	<simpara>See the interaction diagram below:</simpara>
	<figure id="fig_chaci"><title>Agent's content changing interactions</title><imageobject>
		<imagedata fileref="pics/desa_mdl_chg_agents_content_icd.jpg"/> </imageobject></figure>
	<simpara>There are 3 actors here: Client (some subject external to the model), agent and agent's owner. Note, that the
	    interaction doesn't completelly correspond to currently implemented scheme.
	    Currently the agent's content is not accepted by owner (to be more presize the owner is notified
	    and checks out the content but cannot revoke the content changed).
	    It is not consistent with the overall policy - any mutation of agents are to be accepted.</simpara>
	<simpara>This interaction suggests the following DES topology.</simpara>
	<figure id="fig_chacdes"><imageobject>
		<imagedata fileref="pics/desa_change_content.jpg"/> </imageobject></figure>
    </sect1>

    <sect1 id="ds_iccn"><title>Is Connection class needed as specific artifact of connection or references to pair is enough?
	</title>
	<sect2><title>Intro</title>
	    <simpara>Currently in <xref linkend="gls_fapws"/> project specific class CAE_ConnBase for connection.
		So conn point includes all its connection as attributes. But do we really need it. Another approach is
		to keep pairs in conn point instead of the connections.</simpara>
	</sect2>
	<sect2><title>Connections are still needed</title>
	    <simpara>There is use-case when user want to disconnect the conn point from another conn point in the connenctions
		chain. Example is:</simpara>
	    <programlisting>
		State A CP is connected to Object B EP
		Object B EP is connected to internal State C CP
		So Object A CP has reference to final connection State C CP.
	    </programlisting>
	    <simpara>If the user wants to remove particular connection from A to B it can specify the corresponding connection.
		In case if we don't have connections stored for each CP it will be not possible to specify what part of
		connection chain need's to be eliminated because CP stores only final pair in the chain.</simpara>
	    <simpara>So we need both final CPs and connection for any CP in the system. Note that in current
		<xref linkend="gls_fapws"/> CP doens't include its final pairs. Actually the connection in that case
		can be replaced with just direct pair stated in conn point. In FAPWS another solution is used - conn point
		keeps connections. This is because FAPWS uses creating-by-spec approach and connection objects are used
		to create connection.</simpara>
	    <simpara>Why refs to final pairs are needed. They are served as cache and required to avoid long searching of
		final CPs each time transition function requested data from state's inputs.  </simpara>
	</sect2>
	<sect2><title>Facts of connection implementation in <xref linkend="gls_fapws"/></title>
	    <itemizedlist>
		<listitem>There are "source" and "destination" within multilink connection point CAE_ConnPoint. Source 
		    is the ref to the state represented by conn point. 
		    <simpara>Ref CAE_StateBase::ConstructL() to see that state sets itself as "source" pin into
			state output connpoint.</simpara>
		</listitem>
		<listitem>There is reference to state in connpoint. At least "source" part of connpoint is set as
		    pointer to state.
		</listitem>
	    </itemizedlist>
	</sect2>
    </sect1>

    <sect1><title>Do we need interface resolution mechanism?</title>
	<sect2><title>Intro</title>
	    <simpara>All implementations of DES engines including <xref linkend="gls_fapws"/> is considering interface as
		its atomic element.  Keeping in mind that low-level DES is to be used for creating mutable DES the assumption
		would be that all we need is to resolve connection point of mutable DES base agent. Conn point in its turn provides
		access to state's data.</simpara>
	    <simpara>So we can see that in any case there should be some elementary interfaces (conn point, state etc)</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_duc"><title>[<glossterm id="gls_duc">DUC</glossterm>] DES update cycle</title>
	<sect2><title>Actors</title>
	    <simpara>The actors are:</simpara>
		<itemizedlist>
		    <listitem>State - consists of data and transition function</listitem>
		    <listitem>System - consists of states and subsystems. Serves as owner for its state and subsystems.</listitem>
		    <listitem>Subsystem - system</listitem>
		    <listitem>Root system - upper layer system</listitem>
		    <listitem>Cycle controller - controls root system</listitem>
		</itemizedlist>
	</sect2>
	<sect2><title>FAPWS Cycle overview</title>
	    <simpara>Note that base class CAE_EBase of DES elements supports statuses iUpdated, iActive.
		iUpdated shows that the object (State for instance) is updated 
	    and needs to be confirmed. iActive shows that the object is not up-to date and needs to be updated.</simpara>
	    <orderedlist>
		<listitem>On system creation it and all it's subsystems and states are marked as active. This is done in base class </listitem>
		<listitem>Cycle controller request root system to update in case it's active (API: CAE_EBase::Update)</listitem>
		<listitem>Root system propagates update request to it's components. Note that each system during the proparation process sets
		    the component to the state iUpdated.</listitem>
		<listitem>On "Update" request states recalculate it's data (API CAE_StateBase::DoTrans)</listitem>
		<listitem>Cycle controller request root system to confirm updates (API: CAE_StateBase::Confirm)</listitem>
		<listitem>Root system propagates confirm request to its components</listitem>
		<listitem>On "Confirm" request state checks if current data got via update differs from final data (i.e. confirmed data).
		    If so state copies data to its confirmed data register and notifies all states dependent (i.e.
		    connected to the current state output) (API: CAE_EBase::SetActive).</listitem>
		<listitem>On SetActive request any DES elements proparates the request to its owner.</listitem>
	    </orderedlist>
	    <simpara>Notes:</simpara>
	    <orderedlist>
		<listitem>Do we really need iUpdated status? </listitem>
	    </orderedlist>
	</sect2>
	<sect2><title>GRAYB Cycle overview</title>
	    <simpara> Sketchy the cycle is as: </simpara>
	    <orderedlist>
		<listitem>On system creation it and all it's subsystems and states are marked as active (API: SetActive).</listitem>
		<listitem>Cycle controller request root system to update in case it's active (API: Update)</listitem>
		<listitem>Root system propagates update request to it's components</listitem>
		<listitem>On "Update" request states recalculate it's data and mark itself as updated (API: SetUpdated)</listitem>
		<listitem>Cycle controller request root system to confirm updates (API: Confirm)</listitem>
		<listitem>Root system propagates confirm request to its components</listitem>
		<listitem>On "Confirm" request state copies data to its confirmed data register and notifies all states dependent (i.e.
		    connected to the current state output) (API: OnUpdated).
		    <programlisting> NOTE: I don't see the logic of generating notification only in case of state data is changed. To analyze.
		    </programlisting>
		</listitem>
	    </orderedlist>
	</sect2>
	<sect2 id="ds_duc_async"><title>Proposed DES update cycle - asynchronous variant</title>
	    <simpara>Asynchronous variant assumes that APIs doesn't return operation completion confirmation. This causes to elements interaction
	    get more complicated than that in case of sync APIs.</simpara>
	    <simpara>The foollowing API is proposed:</simpara>
	    <simpara>Owned element in hierarchy. API supports descending signals.</simpara>
	    <itemizedlist>
		<listitem>Update</listitem>
		<listitem>Confirm</listitem>
		<listitem>OnActivatedHandled - responce from owner on OnCompActivated</listitem>
	    </itemizedlist>
	    <simpara>Provider interface of state - provides the data for another state. API supports horisontal signals.</simpara>
	    <itemizedlist>
		<listitem>OnChangedHandled() - confirmation on OnSourceChanged from dependant</listitem>
		<listitem>GetData() - request of getting states data</listitem>
	    </itemizedlist>
	    <simpara>Consumer interface of state - receives state's data. API supports horisontal signals.</simpara>
	    <itemizedlist>
		<listitem>OnSourceChanged() notification- when provider data is changed (i.e. inputs)</listitem>
		<listitem>ReceiveData() - request of receiving data from provider</listitem>
	    </itemizedlist>
	    <simpara>Owning element in hierarchy. API supports ascending signals.</simpara>
	    <itemizedlist>
		<listitem>OnCompActivated - when component marks itself active</listitem>
		<listitem>OnCompUpdated - when compoments completes its update</listitem>
		<listitem>OnCompConfirmed - when compoments completes its confirm</listitem>
	    </itemizedlist>
	    <simpara>See the diagram below outlining the APIs</simpara>
	    <figure id="fig_puca"><title>Proposed DES update cycle asynchronous  - APIs</title><imageobject>
		    <imagedata fileref="pics/desa_cycle_async_clsd.jpg"/> </imageobject></figure>
	    <simpara>The cycle is (simplified diagram):</simpara>
	    <figure id="fig_desa_cycle_async_s_icd"><title>Proposed DES update cycle (simplified) - APIs</title><imageobject>
		    <imagedata fileref="pics/desa_cycle_async_s_icd.jpg"/> </imageobject></figure>
	    <simpara>On the diagram State2 is dependent from State1. So State2 input is connected to State1 output. State2
		buffers the sign of activation on confirmation phase (on OnSourceChanged signal). On update phase State2 requests
		data from State1.</simpara>
	    <simpara>The full cycle is:</simpara>
	    <orderedlist>
		<listitem>On system creation the system and all it's subsystems and states are marked as active. This is done in base class
		    constructor.</listitem>
		<listitem>Root system send update request to it's components (Owned::Update) for each component that is active</listitem>
		<listitem>Subsystems just propagate ascending and descending requests.</listitem>
		<listitem>On "Update" request states recalculate it's data and notifies owner on update completion (Owning::OnCompUpdated).</listitem>
		<listitem>Subsystem checks if all comps get updated and if so notifies owner (Owning::OnCompUpdated). Root system checks if
		    all comps get updated and then initiates confirmation stage with Owned::Confirm to all its updated components.</listitem>
		<listitem>Subsystems propagates Confirm downwards.</listitem>
		<listitem>State receives Confirm request, checks if updated data differs from what was confirmed on previous cycle. If so then
		    state copies updated data to confirmed data and notifies all depentants (Dependant::OnDepChanged)</listitem>
		<listitem>Dependants received OnDepChanged notification marks themself as active and notifies upward with Owning::OnCompActivated</listitem>
		<listitem>OnCompActivated notifications are propagated upwards till root system.</listitem>
	    </orderedlist>
	    <simpara>See the diagram below outlining the interactions</simpara>
	    <figure id="fig_desa_cycle_async_icd"><title>Proposed DES update cycle - APIs</title><imageobject>
		    <imagedata fileref="pics/desa_cycle_async_icd.jpg"/> </imageobject></figure>
	</sect2>
	<sect2 id="ds_duc_sync"><title>Proposed DES update cycle - synchronous variant</title>
	    <simpara>The foollowing API is proposed:</simpara>
	    <simpara>Owned element in hierarchy. API supports descending signals.</simpara>
	    <itemizedlist>
		<listitem>Update</listitem>
		<listitem>Confirm</listitem>
	    </itemizedlist>
	    <simpara>Destination element - element that receives state's data. API supports horisontal signals.</simpara>
	    <itemizedlist>
		<listitem>OnSourceChanged - when source is changed (i.e. inputs)</listitem>
	    </itemizedlist>
	    <simpara>Owning element in hierarchy. API supports ascending signals.</simpara>
	    <itemizedlist>
		<listitem>OnCompActivated - when component marks itself active</listitem>
	    </itemizedlist>
	    <simpara>See the diagram below outlining the APIs</simpara>
	    <figure id="fig_desa_cycle_sync_api"><title>Proposed DES update cycle synchronous - APIs</title><imageobject>
		    <imagedata fileref="pics/desa_cycle_sync_api_clsd.jpg"/> </imageobject></figure>
	</sect2>
    </sect1>

    <sect1 id="ds_conn"><title>Connections</title>
	<sect2 id="ds_conn_cpt"><title>Compatibility</title>
	    <sect3><title>Intro</title>
		<simpara>Ref <ulink url="rq_cpcmp"/> for the requirements. According to the requirement the connection points needs to be 
		compatible to be connected. What the compatibility can be based on? What would be approaches of checking the compatibility?</simpara>
	    </sect3>
	    <sect3><title>Capabilities as base of compatibility.</title>
		<simpara>One of the approaches is that any CP has to posess set of capabilities that can be used for checking if CPs are
		    compatible. For instance the direction (Input/Output) can be one of such capabilities.</simpara>
	    </sect3>
	</sect2>
	<sect2><title>CP as the representative of owning node. Two-way utilizing of CP.</title>
	    <simpara>CP represents the node (state or system) that includes thes CP. For instance state's output CP represents state via
		specific state's interface (MState) that gives access to state's data. State's inputs represents containing state via interface
		MStateObserver that allows to notify the state of input's change.</simpara>
	    <simpara>So when two CPs A and B are connected they can be used in two-way manner. Owner A can interact to owner B via interface
		represented by B, and vise versa. So any CP "provides" (i.e. represents) some interface and requires some interface from its
		pair.</simpara>
	    <simpara>Any CP provides the client (i.e. the node owning the CP) with the set of interface instances represented by connected CPs.
		How CP knows what ifaces it needs to provide and what interface it requires?
		Client creating the CP should provide this information. These interface types can be included into CP capabilities. We can
		use C++ template parameter to customize CP with "Provided" and "Required" interface types.</simpara>
	    <simpara>Actually at the moment we don't need more interface type that that the state provides and requires - MStateObserver and MState.
		So these interfaces can be selected basing on CP direction (input or output).
	    </simpara>
	</sect2>
	<sect2><title>Connection</title>
	    <sect3><title>Intro</title>
		<simpara>Connection (or connector) is the the object that creates connection between two connection points.
		    It is the question if we need connector as specific object, in fact we can establish connection via specifying
		    pair for both of connection points being connected.</simpara>
	    </sect3>
	    <sect3><title>Connection point is needed for dynamic configuration of the connections.</title>
		<simpara>There is use-case when connection should be established in the scope of DES system running, i.e. some
		state transition function can update connection (or data of connection) as state's data.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_conn_chain"><title>Creating point-to-point connection: chain of connections</title>
	    <simpara>Almost all connections in DES are point-to-point: output to input, etc. On another hand this is not just simple connection
		one point to another but configured chain of connections, so many connection points are participated in that chain.
		The chain links are connections but links joints are special connection points, Extension in example.</simpara>
	    <sect3><title>Why do we need such connection on form of chain? </title>
		<simpara>This allows us to create complex topology of connections, supporting hierarchy of
		    systems where internal system state output connects to system output that in turn connects to another system input etc. </simpara>
		<simpara>Also the main capability of connection is the mechanism of enlargement. We should be allowed to create any flexible 
		topology of connection. One example is simple extension of connection.</simpara>
	    </sect3>
	    <sect3 id="ds_conn_chain_mdt"><title>Why do we need mechanism of mediators?</title>
		<simpara>One of the reasons is that we need to support directional connections, like input-to-output. So each conn point in the chain
		    has to understand that from on side it is connected to "source" and from another - to "destination". Here we apply the 
		    proved approach, where connection itself is not directional but conn points themselfs play role of "source" and "destination". </simpara>
		<simpara>Mediator plays role of glue that binds partial p-to-p connection to the chain:</simpara>
		<programlisting>
		     |    1st p-to-p          mediator   2nd p-to-p
		     |  CP1=======CP2----------->CP3==================CP4
		</programlisting>
		<simpara>Relation to mediator is directional (asymmetric).</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1><title>Support of system topology. Node base for all nodes in the system topology.</title>
	<sect2><title>Intro</title>
	    <simpara>The whole system is combined from subsystems and states. This gives up tree-type topology for the system. Similar topology 
		can be applied to connection network, where connection point can have complex treeish structure in order to compact intersystems 
		connection. So it makes sense to support treish hierarchy on level of base class - Node.</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_mtr"><title>Meta transitions</title>
	<sect2 id="ds_mtr_intro"><title>Intro</title>
	    <simpara>Meta transition is the term describing case when some system's state controls another system's structure.
		So the data of state is not primitive data but structure of some system. The structure of system means the components
		of the system (sub-systems, states, connections, connection points). Can system posess transition (i.e. state) that
		controls the system itself? In theory so.</simpara>
	</sect2>
	<sect2><title>Update cycle for meta transition</title>
	    <simpara>For simple state the update cycle includes update and confirm phases. This allows to sync the whole system
		movement. How this sync can be supported for meta transitions?</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_ssbi"><title>Using syncronization scheme with state vector buffered in inputs (Input level buffering, IB)</title>
	<sect2><title>Intro</title>
	    <simpara>Currently after each cycle of system synchronization the overall state
		vector is kept in outputs of states. This approach is convenient because it
		is align with the system math model at most. The drawback of this approach is
		that on each cycle of system sync the states have to get the status from the
		states outputs to theirs connected inputs. So the relation between state's 
		output and connected input of state is bidirectional: input offers interface
		to be notified of dependent state change, whereas output offers interface to 
		provide its data to dependent input.</simpara>
	    <simpara>But there are alternative.</simpara>
	</sect2>
	<sect2><title>Cons</title>
	    <sect3><title>Cannot use multiple connpoint.</title>
		<simpara>With standard approach the input can contain the set of "required"
		    interfaces. This is the case when multiple outputs are connected to single
		    input connection point. Such mechanism simplifies the system in case when
		    transition function has many identical arguments.</simpara>
		<simpara>Input cache approach potentiallly can use same technik, we just
		    need to have set of data in the input. But the problem here is that
		    there should be association between particular output and data within
		    the input data set. This is because the input should keep the data from
		    unchanged outputs but refresh the data by the request from changed outputs.
		</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_ssbi_pd"><title>Proposed design</title>
	    <simpara>The class diagram is shown below:</simpara>
	    <figure id="fig_ssbi_ps_clsd"><title>Proposed DES update cycle asynchronous with data input buffering. Class diagram.
		    </title><imageobject>
		    <imagedata fileref="pics/desa_cycle_async_ib_clsd.jpg"/> </imageobject></figure>
	    <simpara>Interactions scheme in case of input level data buffering is as:</simpara>
	    <figure id="fig_desa_cycle_async_ib_s_icd"><title>DES cycle for input buffering (simplified) - APIs</title><imageobject>
		    <imagedata fileref="pics/desa_cycle_async_ib_s_icd.jpg"/> </imageobject></figure>
	    <simpara>On the diagram State2 is dependent from State1. So State2 input is connected to State1 output. State2
		buffers the data from State1 on confirmation phase (on ReceiveData signal). So on update phase State2 doesn't
		need interaction to State1.</simpara>
	    <simpara>Compare IB variant to the initial variant without data buffering, ref <xref linkend="fig_desa_cycle_async_s_icd"/>.
		We see that data buffering variant needs only one interaction State1 to State2 during the cycle. This is because
		State2 gets activation sign via receiving signal ReceiveData from State1. So from interaction point of view
		IB variant is more effective.</simpara>
	    <simpara></simpara>
	</sect2>
    </sect1>

    <sect1><title>Verification: Regex</title>
	<sect2><title>Intro</title>
	    <simpara>This verification aim is to prove DESA with regular expression handler model.</simpara>
	</sect2>
	<sect2><title>First approach of implementing regex engine.</title>
	</sect2>
    </sect1>

    <sect1 id="ds_areq"><title>Asynchronous requests - client/server approach.</title>
	<sect2><title>Intro</title>
	    <simpara>One kind of interfaces of async system would be so called async requests. This happens when we consider async system not as 
		DES but as regular C++ object that offers some interfaces for issuing request to the object. In fact the most usual native SW programming
	       model is just a chain of clients-services.  This "simulation" of async system
		can simplify the design of multi-agent. The question is how to implement such simulation using DES approach. Is it real design 
		solution?</simpara>
	    <simpara>As a request we can consider any getter, e.g. grayb Elem::GetNode(). So let's imagine there is some subsystem (maybe state) that
		has input "uri" and output "node". So we can connect "client" to input and get result from this subsystem output. But what is there are many
		client for this service?</simpara>
	    <simpara>Don't forget that normally subsystem is just "transformer", so if we need that sybsystem handles the "requests" we need to 
		create special mechanism allowing connecting many clients to subsystem, ordering the data from clients, identifying the data from clients,
		identifying output corresponding to particular client etc.</simpara>
	</sect2>
	<sect2><title>Dedicated Connection point for request</title>
	    <simpara>One possible solution for async requests in DES is to have dedicated connection point for it. This point provides iface to set request's
		signature (i.e. parameters). This point requres iface to set the result of the request.</simpara>
	    <simpara>Conn point allows multiple connections so multiple clients can do requests to service system.</simpara>
	    <simpara>If we extend this aproach we will come to the design of pool of subsystems handling multiple request: there is "multichannel" connpoint for
		input_request/output_feedback, adding new channel to it causes creating also new handler. Accordingly, removing the connpoint channel causes removal
		of handler. So many request to the system causes system itlsel increasing by new handler of the requests.
	    </simpara>
	    <simpara>Pros of this approach:</simpara>
	    <itemizedlist>
		<listitem>The handler of particular request is connected to requester, so any kind of request identification is not required.</listitem>
	    </itemizedlist>
	</sect2>
    </sect1>

    <sect1 id="ds_cpubi"><title>Connection points for Unblocked interaction</title>
	<sect2><title>Intro</title>
	    <simpara>Ref <ulink url="../../../desmag/doc/design/index.html#ds_asub"/> for discussion of unblocked interactions.</simpara>
	    <simpara>Actually the idea of using of events systems is to provide mechanism of such unblocked interactions. But at the moment (d4de8b103d76b2cd)
		the connection points interactions is blocking. So CP as core part of DES is blocking itself that preevents creating unblocking systems based
		on DES. We need to provide unblocking conn point mechanism.</simpara>
	    <simpara>There can be the foolowing approaches considered:</simpara>
	    <itemizedlist>
		<listitem>To have both blocking and unblocking CP, ref <xref linkend="ds_cpubi_bbu"/></listitem>
		<listitem>To have only unblocking CP based on state machine, ref <xref linkend="ds_cpubi_ousm"/></listitem>
	    </itemizedlist>
	</sect2>
	<sect2 id="ds_cpubi_bbu"><title>Approach: to have both blocking and unblocking CP</title>
	    <simpara>Blocking CP is still usable in case connection/disconnection can be done in blocking manner. For instance for connecting CP of states
		running in one thread.
	    </simpara>
	</sect2>
	<sect2 id="ds_cpubi_ousm"><title>Approach: having only unblocking CP based on callbacks state machine</title>
	    <sect3><title>Intro</title>
		<simpara>Ref <xref linkend="ds_smcsc"/> for design of state machine besed on callback with stored context.</simpara>
	    </sect3>
	    <sect3><title>How to process responce from request handler?</title>
		Connpoints interactions are managed by owned system. Thus this system initiates conn points interaction (for instance request one CP connect to
		another CP) and correspondigly receives response from conn point. How to process this response. In our case it is simple for system is DES so
		has unblocking nature. System just needs to have response handling state and  assosiate some input of handling state to the response.
		The response then updates the input properly that causes hadling state transition. 
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_smcsc"><title>State machine based on callback with stored context.</title>
	<sect2><title>Intro</title>
	    <simpara>There are many technics of implementing state machine. Here one of them is being considered.</simpara>
	    <simpara>Let's assume that the system is combined from the objects. Each object in our case is implemented with normal
		C++ class. The class can be considered as state machine - it contains internal state (attributes, we also will call it "context")
		and transitons (methods).  Assuming that the classes interaction is not blocking, i.e. any initial transition (method) of some class 
		can initiate anoter class context change via invoking this state method but class initator doesn't wait the method's return data, instead, it passes
		callback function to method, so class handler invokes this call back on the method fulfilled (transition done). The initiator shares it's context
		with callback, including the initial method local variables, so the callback can be cosidered as another transition the context with 
		taking to account hadler state passed as arguments of callback. </simpara>
	    <simpara>This interaction can be simply interpret in the terms of state machine, ref the diagram below:</simpara>
	    <figure id="fig_smcb"><imageobject> <imagedata fileref="pics/desa_sm_callback_based.jpg"/> </imageobject></figure>
	    <simpara>Class-initiator passed its callback to the initial method - this callback can be interpreted as a notification to 
		next state (class-initiator initial transition continuation) of handler method output updated, where callback argument
		is an input of input of next state. This notification also can be considered as just input that we update in order to next transition.</simpara>
	    <simpara>Note, that the interface in that case is the set of such "inputs".</simpara>
	    <simpara>The connection of states is being performed dynamically: current state transition creates next state inputs</simpara>
	    <simpara>We can consider some design approaches here:</simpara>
	    <itemizedlist>
		<listitem>Functor with partial context, ref <xref linkend="ds_smcsc_fpc"/></listitem>
		<listitem>common context for non blocking operation, ref <xref linkend="ds_smcsc_cco"/></listitem>
	    </itemizedlist>
	</sect2>
	<sect2 id="ds_smcsc_fpc"><title>Approach: Functor with partial context</title>
	    <simpara>We can introduce interface of state - just one transition fucntion. Then we can define such state as class that implements this interface
		(note that this class is actually a closure). This class constructor gets inputs and input to the next state (states). Passing the input
		to the state is act of connection the state output to next state input. </simpara>
	    <sect3><title>State desing in case of using states for existing C++ system re-implementation</title>
		<simpara>In many cases we use this design to re-implement some standard C++ system (set of interacting classes) in orider to 
		    support async non-blosking system. In that case the states are used only for implement class methods procedure. This means that
		    we needs to consider class attributes as "persistent" part of states. There is another part, not repsistent, transient that is
		    counterpart of stack variables of the class method. State also needs to use this class method and other class methods in scope
		    of transition. This means the state needs to have class as a context. The context keeps persistent part of overall system "status" and
		    utility methods.</simpara>
		<simpara>Why this "combined" design is used? This is because the direct movement (the movement that moves class local status) can
		be simply done by class method, but handling result from async non-bloking requests to another classes is better do in states. </simpara>
		<simpara>In this case the constructor of state shall get context, inputs and connection to next state.</simpara>
		<simpara>Methods of class also needs to be modified. Many of them needs to get inputs to state (states)(in many cases the states are to get
		    callback) in order to continue the calculation process. So the modified class interface will consists of the regular methods, some (or many)
		    of them gets next state (callback) as attribute.</simpara>
	    </sect3>
	    <sect3><title>What if we want to create system from scrath using states only?</title>
	    </sect3>
	</sect2>
	<sect2><title>Why do we need to pass interim contex (local variables) from initial transition to callback?</title>
	    <simpara>Because more that one "clients" can invoke handling methods. So "movement" in handling method depends on mehod arguments
		(can differs for clients). In case if only one client is allowed then the local content can be moved to "global" level - to 
		handling class attributes. Compare this with <xref linkend="ds_areq"/>. We call initiator "client" because this kind of interaction
		looks similar to client-server architecture - client initiates the interaction.</simpara>
	    <simpara>There can be another approach used: we can register clients and then keep clients related contens in class context. In that case
		we don't need to pass the local context to callback - it can take it from client related context. We also need to propagte client id to each
		secondary request.</simpara>
	</sect2>
	<sect2><title>Why not use same approach for connection in DES?</title>
	    <simpara>As it was mentioned callback based state machine doesn't use dedicated connections. Instead the connection for output is
		set as callback when the state is created.</simpara>
	    <simpara>Does is make sense to use same approach for DES instead of dedicated connection points?</simpara>
	</sect2>
	<sect2 id="ds_smcsc_cco"><title>Approach modification: common context for non blocking operation (<xref linkend="gls_cco"/>)</title>
	    <sect3><title>Intro</title>
		<simpara>Initially we attempt the approach "Functor with partial context", ref <xref linkend="ds_smcsc_fpc"/>. In that approach we
		    store just partial context in the callback function, the context that needed for callback procedure itselt. So each callback needs to 
	       create next callback, pass the partial context for it's contstuctor, invoke request to another object  passing the callback to the operation.</simpara>
	   <simpara>What if we from beginning use the class that contains the whole context (all local data in regular sycnronous operation) and then
	   add all the callbacks as method of that class. In this case all callbacks by default has access to context.</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_csd"><title>Client-server design</title>
	<sect2><title>In many cases it is convenient to consider DES as serice. Example is "simulating" regular C++ service objects with DES, ref
		<xref linkend="ds_areq"/></title>
	</sect2>
    </sect1>

    <sect1 id="cr"><title>Change requests</title>
	<sect2 id="cr_001"><title>Error handling: notification of dangling output on state confirmation</title>
	    <sect3>Requirements
		<simpara><ulink url="../requirements/index.html#uc_004"/></simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_ena"><title>Example: node of agents</title>
	<sect2><title>Intro</title>
	    <simpara>This example is some kind of network of agents, like <ulink url="../../../grayb/"/></simpara>
	</sect2>
	<sect2><title>Thoughts</title>
	    <sect3><title>Element as system with controllers</title>
		<simpara>It's obvious that </simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1><title>The whole system as DES</title>
	<simpara>The initial idea of creating multi agent element basing on low-level DES (ref <xref linkend="ds_intro_i"/>) has a logical conflict.
	    The whole system has to be implemented as low-level DES in that case, but not separate element. This is because the DES nature of interface of
	element can be utilize only in the scope of parent system, i.e. the system cycle has to be working.</simpara>
    </sect1>

    <sect1 id="ds_th"><title>To handle</title>

    </sect1>

</article>
